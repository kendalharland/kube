// Kube  :  An OpenGL based game engine.
// Copyright (C) 2021 Kendal Harland GPL-3.0-only
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#pragma once

#include <math.h>
#include <memory>

#include <kube/logging.h>

#include <glm/glm.hpp>

namespace kube {

// AnimationState keeps track of the progress made during an animation.
//
// Progress is measured as a gradual transition from 0% to 100% completion of
// an animation, where the percentage is expressed as a floating point number
// on the closed interval [0,1].
class AnimationState {
public:
  AnimationState(float speed = 1) : speed_(speed) {}

  // IsComplete returns true if the animation state has reached 100%.
  bool IsComplete() { return progress_ >= 1; }

  // Update advances the animation state.
  //
  // To scale the rate of progression, `deltaTime` is multiplied by the `speed`
  // given when this animation state was constructed.
  void Update(float deltaTime) {
    progress_ += deltaTime * speed_;
    if (progress_ > 1.f) {
      progress_ = 1.f;
    }
  }

  float GetProgress() { return progress_; }

private:
  float speed_ = 1.0f;
  float progress_ = 0;
};

// Curves move along the range of y-values on the closed interval [0, 1].
// They are expressed as functions of a t value, which is basically the
// x-axis value between 0 and 1. Curves determine *how* the animation moves
// along the Tween's range. For example, a sin curve will oscillate between
// both endpoints. A exponential curve will start slow, but increase in speed
// drastically with each step. A logrithmic curve will start fast, but taper
// off as it progresses, and perhaps never complete depending on the limit of
// the curve.
class Curve {
public:
  typedef float (*CurveFunc)(float x);

  explicit Curve(CurveFunc f) : f_(f) {}

  float Value(float x) { return f_(x); }

private:
  CurveFunc f_;
};

static const Curve Linear = Curve([](float x) { return x; });
static const Curve Sin = Curve([](float x) { return (float)sin(x * M_PI_2); });

// Tween maps real-world values to the positions on the animation
// interval. For example a tween from the color red to the color blue would
// determine how much the red has been converted to blue. If the animation is
// 50% complete, this might result in the color purple. Tweens are the
// "visible" portion of the animation.
//
// Typically the User holds pointers to an Animation and an instance of a
// concrete Tween type. Derived Tween implementations should provide a
// getter the caller can use to retrieve the current value.
template <typename Impl> class Tween {
public:
  void Update(float t) { GetImpl()->Update(t); }

private:
  Impl &GetImpl() { return static_cast<Impl &>(this); }
};

// Animation represents a gradual transition between two states.
//
// An animation's progress is represented by the closed interval [0, 1] where
// 0 = not started and 1 = complete. The animation always moves forward, from
// 0 to 1.  The animation is updated incrementally based on the amount of time
// that has passed (deltaTime) which is assumed to be mapped from clock-time
// to wall time by the caller. To get the animation to complete faster, multiply
// deltaTime by some constant speed.
//
// An Animation is usually used together with a Tween, which maps the values
// generated by the animation into the callers's domain. For example:
//
//     auto tween = ColorTween(Color::RED, Color::BLUE);
//     auto animation = Animation(1.f, Linear);
//
//     void Update(int deltaTime) {
//       auto state = animation.Update(deltaTime);
//       auto old_color = tween.GetColor();
//       tween.Update(state);
//       auto new_color = tween.GetColor();
//       KUBE_INFO << "Color changed from " << old_color << " to " << new_color;
//     }
class Animation {
public:
  explicit Animation(float speed, Curve curve) : state_(AnimationState(speed)), curve_(curve) {}

  float Update(float deltaTime) {
    state_.Update(deltaTime);
    return curve_.Value(state_.GetProgress());
  }

  // IsComplete returns true if the animation has reached 100%.
  bool IsComplete() { return state_.IsComplete(); }

private:
  AnimationState state_;
  Curve curve_;
};

class FloatTween : Tween<FloatTween> {
public:
  FloatTween(float min, float max) : min_(min), max_(max) {}

  void Update(float t) { value_ = (max_ - min_) * t; }

  float GetValue() { return value_; }

private:
  float min_ = 0;
  float max_ = 1;
  float value_ = 0;
};

} // namespace kube
